/*
 * rv32emu is freely redistributable under the MIT License. See the file
 * "LICENSE" for information on usage and redistribution of this file.
 */

#pragma once

#include <stddef.h>
#include <stdint.h>

#include "riscv_private.h"
#include "utils.h"

/* Jump condition codes for branch instruction code generation.
 * Values match x86-64 Jcc opcodes; on Arm64, emit_jcc_offset() maps these
 * to equivalent condition codes. Used by both architectures as symbolic
 * constants for conditional/unconditional jumps.
 */
#define JCC_JE 0x84  /* Jump if Equal (conditional) */
#define JCC_JNE 0x85 /* Jump if Not Equal (conditional) */
#define JCC_JL 0x8c  /* Jump if Less - signed (conditional) */
#define JCC_JGE 0x8d /* Jump if Greater or Equal - signed (conditional) */
#define JCC_JB 0x82  /* Jump if Below - unsigned (conditional) */
#define JCC_JAE 0x83 /* Jump if Above or Equal - unsigned (conditional) */
#define JCC_JMP 0xe9 /* Jump unconditional */

struct jump {
    uint32_t offset_loc;
    uint32_t target_pc;
    uint32_t target_offset;
#if RV32_HAS(SYSTEM)
    uint32_t target_satp;
#endif
};

struct offset_map {
    uint32_t pc;
    uint32_t offset;
#if RV32_HAS(SYSTEM)
    uint32_t satp;
#endif
};

struct jit_state {
    set_t set;
    uint8_t *buf;
    uint32_t offset;
    uint32_t stack_size;
    uint32_t size;
    uint32_t entry_loc;
    uint32_t exit_loc;
    uint32_t org_size; /* size of prologue and epilogue */
    uint32_t retpoline_loc;
    struct offset_map *offset_map;
    int n_blocks;
    struct jump *jumps;
    int n_jumps;
};

struct host_reg {
    uint8_t reg_idx : 5;   /* index to the host's register file */
    int8_t vm_reg_idx : 6; /* index to the vm register */
    bool dirty : 1; /* whether the context of register has been overridden */
    bool alive : 1; /* whether the register is no longer used in current basic
                       block */
};

struct jit_state *jit_state_init(size_t size);
void jit_state_exit(struct jit_state *state);
void jit_translate(riscv_t *rv, block_t *block);
typedef void (*exec_block_func_t)(riscv_t *rv, uintptr_t);

/* JIT misaligned memory access handler.
 * Performs misaligned load/store operations using byte-level memory accesses.
 */
void jit_misaligned_handler(riscv_t *rv,
                            uint32_t addr,
                            uint32_t vreg_idx,
                            uint32_t type,
                            bool is_store);

#if RV32_HAS(T2C)
void t2c_compile(riscv_t *, block_t *, pthread_mutex_t *);
typedef void (*exec_t2c_func_t)(riscv_t *);

/* The jit-cache records the program counters and the entries of executable
 * instructions generated by T2C. Like hardware cache, the old jit-cache will be
 * replaced by the new one which uses the same slot.
 */

/* The size of jit-cache table should be the power of 2, thus, we can easily
 * access the element by masking the program counter.
 */
#define N_JIT_CACHE_ENTRIES (1 << 12)

/* jit_cache entry for T2C compiled code lookup.
 * Thread safety: Uses seqlock pattern for lock-free readers.
 * - Writers (under cache_lock): increment seq to odd, write entry+key,
 *   increment seq to even
 * - Lock-free readers (LLVM-generated): read seq1, if odd retry; read
 *   entry+key; read seq2; if seq1 != seq2 retry Seqlock ensures readers see
 *   consistent (key, entry) pairs without ABA problem.
 */
struct jit_cache {
    uint32_t seq; /* sequence counter: odd = write in progress, even = stable */
    uint64_t key; /* program counter, composed to satp in system simulation */
    void *entry;  /* entry of JIT-ed code */
};

/* Verify struct layout requirements for lock-free seqlock reads and LLVM IR.
 *
 * The jit_cache struct layout must match the LLVM type definition in t2c.c:
 *   LLVM: { i32 seq, i32 pad, i64 key, ptr entry }
 *   Offsets: seq=0, pad=4, key=8, entry=16 (on 64-bit)
 *
 * The key field must be 8-byte aligned for atomic 64-bit loads without
 * requiring libatomic. The entry field must be pointer-aligned.
 *
 * If this struct layout changes, the LLVM type in t2c.c must be updated to
 * match (search for "jit_cache_memb" in t2c.c).
 */
static_assert(offsetof(struct jit_cache, seq) == 0,
              "jit_cache.seq must be at offset 0 to match LLVM IR");
static_assert(offsetof(struct jit_cache, key) == 8,
              "jit_cache.key must be at offset 8 to match LLVM IR");
static_assert(offsetof(struct jit_cache, entry) == 16,
              "jit_cache.entry must be at offset 16 to match LLVM IR");
static_assert(offsetof(struct jit_cache, key) % 8 == 0,
              "jit_cache.key must be 8-byte aligned for atomic loads");
static_assert(offsetof(struct jit_cache, entry) % sizeof(void *) == 0,
              "jit_cache.entry must be pointer-aligned for atomic loads");

struct jit_cache *jit_cache_init();
void jit_cache_exit(struct jit_cache *cache);
void jit_cache_update(struct jit_cache *cache, uint64_t key, void *entry);
void jit_cache_clear(struct jit_cache *cache);
void jit_cache_clear_page(struct jit_cache *cache, uint32_t va, uint32_t satp);

/* Dispose LLVM execution engine when a T2C-compiled block is freed */
void t2c_dispose_engine(void *engine);

/* Wrapper for cache cleanup - disposes LLVM engine from a block */
void t2c_dispose_block_engine(void *block);
#endif
